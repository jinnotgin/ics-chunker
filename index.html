<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>Calendar ICS File Chunker</title>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.7.1/jszip.min.js"></script>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
		<link
			href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;700&amp;display=swap"
			rel="stylesheet"
		/>
		<style>
			body {
				font-family: "Roboto", Arial, sans-serif;
				max-width: 800px;
				margin: 0 auto;
				padding: 20px;
				background-color: #f5f5f5;
				color: #333;
			}

			.container {
				background-color: white;
				padding: 30px;
				border-radius: 8px;
				box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
			}

			h1 {
				color: #2c3e50;
				margin-bottom: 20px;
			}

			p {
				line-height: 1.6;
				color: #555;
			}

			.file-input-wrapper {
				display: flex;
				align-items: center;
				margin-bottom: 20px;
				gap: 0.5rem;
			}

			#icsFileInput {
				flex-grow: 1;
				padding: 10px;
				border: 1px solid #ddd;
				border-radius: 4px;
			}

			button {
				background-color: #3498db;
				color: white;
				border: none;
				padding: 10px 20px;
				border-radius: 4px;
				cursor: pointer;
				transition: background-color 0.3s;
			}

			button:hover {
				background-color: #2980b9;
			}

			button:disabled {
				background-color: #bdc3c7;
				cursor: not-allowed;
			}

			#results {
				margin-top: 30px;
			}

			.chunk-list {
				display: grid;
				grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
				gap: 10px;
				margin-bottom: 20px;
			}

			.chunk-item {
				background-color: #f0f0f0;
				padding: 10px;
				border-radius: 4px;
				text-align: center;
			}

			.chunk-item a {
				display: block;
				color: #3498db;
				text-decoration: none;
				margin-bottom: 5px;
			}

			.chunk-item a:hover {
				text-decoration: underline;
			}

			.download-all-wrapper {
				text-align: center;
				margin-top: 20px;
			}

			#downloadAllButton {
				font-size: 1.1em;
				padding: 12px 24px;
			}

			.spinner {
				display: inline-block;
				width: 12px;
				height: 12px;
				border: 3px solid rgba(255, 255, 255, 0.3);
				border-radius: 50%;
				border-top-color: #fff;
				animation: spin 1s ease-in-out infinite;
				margin-right: 10px;
			}

			@keyframes spin {
				to {
					transform: rotate(360deg);
				}
			}

			footer {
				text-align: center;
				margin-top: 30px;
				color: #7f8c8d;
				font-size: 0.9em;
			}

			footer a {
				color: #3498db;
				text-decoration: none;
			}

			footer a:visited {
				color: #3498db;
			}

			footer a:hover {
				text-decoration: underline;
			}
		</style>
	</head>
	<body>
		<div class="container">
			<h1>Calendar ICS File Chunker</h1>
			<p>
				This tool is designed to assist with calendar migration efforts by
				breaking up large ICS files into smaller, more manageable chunks. It's
				particularly useful when dealing with calendars that have a high number
				of events and need to be split for easier processing or import into
				other systems.
			</p>
			<div class="file-input-wrapper">
				<input type="file" id="icsFileInput" accept=".ics" />
				<button id="processButton">Process File</button>
			</div>
			<div id="results"></div>
		</div>
		<footer>
			Made by <a href="https://linjin.me" target="_blank">Jin</a>, with
			<a href="https://www.anthropic.com/news/claude-3-5-sonnet" target="_blank"
				>Claude 3.5 Sonnet</a
			>
		</footer>
		<script>
			// Configuration
			const CHUNKING_STRATEGIES = {
				SIZE: "size",
				COUNT: "count",
				// Add more strategies here in the future
			};

			const CHUNKING_CONFIG = {
				strategy: CHUNKING_STRATEGIES.SIZE, // Default strategy
				sizeLimit: 450 * 1024, // 450KB in bytes
				countLimit: 500, // Number of events per chunk (for count-based strategy)
			};

			let originalFileName = "";

			// Main processing function
			async function processICSFile(file) {
				try {
					const content = await readFile(file);
					if (!isValidICSFile(content)) {
						throw new Error("Invalid ICS file");
					}
					const { globalInfo, components } = parseICSFile(content);
					const chunkedComponents = chunkComponents(
						components,
						CHUNKING_CONFIG
					);
					const icsFiles = generateICSFiles(globalInfo, chunkedComponents);
					displayResults(icsFiles);
				} catch (error) {
					alert(`Error: ${error.message}`);
				}
			}

			// File reading function
			function readFile(file) {
				return new Promise((resolve, reject) => {
					const reader = new FileReader();
					reader.onload = (e) => resolve(e.target.result);
					reader.onerror = (e) => reject(new Error("Error reading file"));
					reader.readAsText(file);
				});
			}

			// ICS file validation function
			function isValidICSFile(content) {
				return (
					content.trim().startsWith("BEGIN:VCALENDAR") &&
					content.trim().endsWith("END:VCALENDAR")
				);
			}

			// ICS file parsing function
			function parseICSFile(content) {
				const lines = content.split(/\r\n|\n|\r/);
				let globalInfo = [];
				let components = { VEVENT: [], VTODO: [], VJOURNAL: [], VFREEBUSY: [] };
				let currentComponent = null;
				let inComponent = false;
				let currentType = null;

				for (const line of lines) {
					if (
						line.startsWith("BEGIN:") &&
						components.hasOwnProperty(line.split(":")[1])
					) {
						inComponent = true;
						currentType = line.split(":")[1];
						currentComponent = [line];
					} else if (line.startsWith(`END:${currentType}`)) {
						currentComponent.push(line);
						components[currentType].push(currentComponent.join("\r\n"));
						inComponent = false;
						currentType = null;
					} else if (inComponent) {
						currentComponent.push(line);
					} else {
						globalInfo.push(line);
					}
				}

				return { globalInfo: globalInfo.join("\r\n"), components };
			}

			// Main chunking function
			function chunkComponents(components, config) {
				switch (config.strategy) {
					case CHUNKING_STRATEGIES.SIZE:
						return chunkComponentsBySize(components, config.sizeLimit);
					case CHUNKING_STRATEGIES.COUNT:
						return chunkComponentsByCount(components, config.countLimit);
					// Add more cases for future strategies
					default:
						throw new Error("Invalid chunking strategy");
				}
			}

			// Component chunking function by count
			function chunkComponentsByCount(components, chunkSize) {
				const chunkedComponents = {};
				for (const [type, items] of Object.entries(components)) {
					chunkedComponents[type] = [];
					for (let i = 0; i < items.length; i += chunkSize) {
						chunkedComponents[type].push(items.slice(i, i + chunkSize));
					}
				}
				return chunkedComponents;
			}

			// Component chunking function by size
			function chunkComponentsBySize(components, maxSize) {
				const chunkedComponents = {};
				for (const [type, items] of Object.entries(components)) {
					chunkedComponents[type] = [];
					let currentChunk = [];
					let currentSize = 0;

					for (const item of items) {
						const itemSize = new Blob([item]).size;
						if (currentSize + itemSize > maxSize && currentChunk.length > 0) {
							chunkedComponents[type].push(currentChunk);
							currentChunk = [];
							currentSize = 0;
						}
						currentChunk.push(item);
						currentSize += itemSize;
					}

					if (currentChunk.length > 0) {
						chunkedComponents[type].push(currentChunk);
					}
				}
				return chunkedComponents;
			}

			// Generate ICS files function
			function generateICSFiles(globalInfo, chunkedComponents) {
				const allChunks = Object.values(chunkedComponents).flat();
				return allChunks.map((chunk, index) => {
					const content = [
						"BEGIN:VCALENDAR",
						...globalInfo
							.split(/\r\n|\n|\r/)
							.filter(
								(line) =>
									!line.startsWith("BEGIN:VCALENDAR") &&
									!line.startsWith("END:VCALENDAR")
							),
						...chunk.flat(),
						"END:VCALENDAR",
					].join("\r\n");
					return { name: `chunk_${index + 1}.ics`, content };
				});
			}

			// Display results function
			function displayResults(icsFiles) {
				const resultsDiv = document.getElementById("results");
				resultsDiv.innerHTML = "<h2>Chunked Files:</h2>";

				// Add descriptor about chunked files
				const descriptor = document.createElement("p");
				descriptor.innerHTML = `
        The original ICS file has been split into ${icsFiles.length} chunks, 
        ${
					CHUNKING_CONFIG.strategy === CHUNKING_STRATEGIES.COUNT
						? `each containing up to ${CHUNKING_CONFIG.countLimit} events.`
						: `each up to approximately ${
								CHUNKING_CONFIG.sizeLimit / 1024
						  }KB in size.`
				} You can download individual chunks or all chunks 
        as a zip file.
    `;
				resultsDiv.appendChild(descriptor);

				const chunkList = document.createElement("div");
				chunkList.className = "chunk-list";

				icsFiles.forEach((file, index) => {
					const chunkItem = document.createElement("div");
					chunkItem.className = "chunk-item";

					const downloadLink = document.createElement("a");
					downloadLink.href = URL.createObjectURL(
						new Blob([file.content], { type: "text/calendar" })
					);
					downloadLink.download = file.name;
					downloadLink.textContent = file.name;

					chunkItem.appendChild(downloadLink);
					chunkList.appendChild(chunkItem);
				});

				resultsDiv.appendChild(chunkList);

				const downloadAllWrapper = document.createElement("div");
				downloadAllWrapper.className = "download-all-wrapper";

				const downloadAllButton = document.createElement("button");
				downloadAllButton.id = "downloadAllButton";
				downloadAllButton.innerHTML = "Download All (Zip)";
				downloadAllButton.addEventListener("click", () =>
					downloadZip(icsFiles)
				);

				downloadAllWrapper.appendChild(downloadAllButton);
				resultsDiv.appendChild(downloadAllWrapper);
			}

			// Download zip function
			async function downloadZip(icsFiles) {
				const downloadAllButton = document.getElementById("downloadAllButton");
				downloadAllButton.disabled = true;
				downloadAllButton.innerHTML =
					'<span class="spinner"></span>Preparing ZIP...';

				try {
					const zip = new JSZip();
					icsFiles.forEach((file) => zip.file(file.name, file.content));
					const content = await zip.generateAsync({ type: "blob" });

					// Generate the new zip file name
					const baseName = originalFileName.replace(/\.ics$/i, "");
					const zipFileName = `${baseName}_chunked.zip`;

					saveAs(content, zipFileName);

					downloadAllButton.innerHTML = "Download Complete!";
					setTimeout(() => {
						downloadAllButton.disabled = false;
						downloadAllButton.innerHTML = "Download All (Zip)";
					}, 3000);
				} catch (error) {
					alert(`Error creating ZIP: ${error.message}`);
					downloadAllButton.disabled = false;
					downloadAllButton.innerHTML = "Download All (Zip)";
				}
			}

			// Event listeners
			document.getElementById("processButton").addEventListener("click", () => {
				const fileInput = document.getElementById("icsFileInput");
				const file = fileInput.files[0];
				if (file) {
					originalFileName = file.name;
					processICSFile(file);
				} else {
					alert("Please select an ICS file");
				}
			});
		</script>
	</body>
</html>
